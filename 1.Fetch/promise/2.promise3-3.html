<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Promise:非同期処理</title>
</head>
<body>
<script>

/*2.3.1. 同期と非同期の混在の問題

  これはPromise以外でも適用できるため、もう少し一般的な問題として考えてみましょう。

  この問題はコールバック関数を受け取る関数が、 
  状況によって同期処理になるのか非同期処理になるのかが変わってしまう問題と同じです。

  次のような、コールバック関数を受け取り処理するonReady(fn)を見てみましょう。*/
  //mixed-onready.js

  function onReady(fn) {

    const readyState = document.readyState;

      if (readyState === "interactive" || readyState === "complete") {

          fn();

      } else {

          window.addEventListener("DOMContentLoaded", fn);

      }
  }

  onReady(() => {

      console.log("DOM fully loaded and parsed");

  });

  console.log("==Starting==");

  /*実行結果:Google Chrome-console

    ==Starting==
    DOM fully loaded and parsed
  */  
  
  /*mixed-onready.jsではDOMが読み込み済みかどうかで、 
    コールバック関数が同期的か非同期的に呼び出されるのかが異なっています。

    onReadyを呼ぶ前にDOMの読み込みが完了している
      同期的にコールバック関数が呼ばれる

    onReadyを呼ぶ前にDOMの読み込みが完了していない
      DOMContentLoadedのイベントハンドラとしてコールバック関数を設定する

  そのため、このコードは配置する場所によって、 
  コンソールに出てくるメッセージの順番が変わってしまいます。

  この問題の対処法は、常に非同期で呼び出すように統一することです。
  
  async-onready.js

  function onReady(fn) {
      const readyState = document.readyState;
      if (readyState === "interactive" || readyState === "complete") {
          setTimeout(fn, 0);
      } else {
          window.addEventListener("DOMContentLoaded", fn);
      }
  }
  onReady(() => {
      console.log("DOM fully loaded and parsed");
  });
  console.log("==Starting==");

  この問題については、 Effective JavaScript の 項目67 非同期コールバックを同期的に呼び出してはいけない で紹介されています。

          非同期コールバックは（たとえデータが即座に利用できても）決して同期的に使ってはならない。

          非同期コールバックを同期的に呼び出すと、処理の期待されたシーケンスが乱され、 コードの実行順序に予期しない変動が生じるかもしれない。

          非同期コールバックを同期的に呼び出すと、スタックオーバーフローや例外処理の間違いが発生するかもしれない。

          非同期コールバックを次回に実行されるようスケジューリングするには、setTimeout のような非同期APIを使う。

  — David Herman
  Effective JavaScript

  先ほどの promise.then も同様のケースであり、この同期と非同期処理の混在の問題が起きないようにするため、 Promiseは常に非同期 で処理されるということが仕様で定められているわけです。

  最後に、この onReady をPromiseを使って定義すると以下のようになります。
  onready-as-promise.js

  function onReadyPromise() {
      return new Promise((resolve) => {
          const readyState = document.readyState;
          if (readyState === "interactive" || readyState === "complete") {
              resolve();
          } else {
              window.addEventListener("DOMContentLoaded", resolve);
          }
      });
  }
  onReadyPromise().then(() => {
      console.log("DOM fully loaded and parsed");
  });
  console.log("==Starting==");

  Promiseは常に非同期で実行されることが保証されているため、 setTimeout のような明示的に非同期処理にするためのコードが不要となることが分かります。


*/
  

</script>  
</body>
</html>